# -*- coding: utf8 -*-

###########################################################################
#   This is the package latexparser
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
###########################################################################

# copyright (c) Laurent Claessens, 2010,2012-2016
# email: laurent@claessens-donadello.eu

import codecs

from latexparser.Utilities import ensure_unicode
from latexparser.Utilities import RemoveComments
from latexparser.InputPaths import InputPaths


class LatexCode(object):
    """
    Contains the informations about a LaTeX code.

    This class does not take track of the comments in the code. The symbol % is however kept because it
    is important for paragraphs in LaTeX.

    If your code is in a file, use the function FileToLatexCode:
    FileToLatexCode("MyFile.tex")
    returns a LatexCode instance.
    """
    # In a previous version, we were keeping the comments, but it caused some difficulties because, for example, we had to only perform the
    # replacements outside the comments, so that we had to perform replacements line by line. It was painfully slow. 
    # If you have any idea how to keep track of the comments without slow down the process, please send a patch :)

    # However it is possible to keep the comments using 'keep_comments=True'.
    def __init__(self,given_text,filename=None,oldLaTeX=None,keep_comments=False):
        """
        self.text_brut          contains the tex code as given, with or without the comments, depending on 'keep_comments'

        If one create a codeLaTeX from an other, use derive_from by passing oldLaTeX to __init__
        """
        # If you change something here, it has to be changed in append_file.
        self.given_text = given_text
        if keep_comments :
            self.text_brut = ensure_unicode(self.given_text)
        else :
            self.text_brut = ensure_unicode(RemoveComments(self.given_text))
        self._dict_of_definition_macros = {}
        self._list_of_input_files = []
        self.filename = filename
        self.included_file_list=[]  # When the code is created from files, the filename is recorded here.
        if oldLaTeX :
            self.derive_from(oldLaTeX)
        self.input_paths=InputPaths()
    def derive_from(self,oldLaTeX):
        self.included_file_list=oldLaTeX.included_file_list
    def copy(self):
        """
        Return a copy of self in a new object

        The fact to copy properties here (like 'input_paths') is not really
        efficient because the majority of operations are replacements and
        are returning new objects.
        See for example 
        RoughSources.LatexCodeToRoughSource
        Although 'new_code' is at the beggining a 'copy', we still have to update
        by hand the input_list.
        """
        A = LatexCode(self.text_brut)
        A.input_paths=self.input_paths
        return A
    def save(self,filename=None,preamble=True):
        """
        Save the code in a file.
        
        Optional <filename> provides a file name that overrides the self.filename. If none of filename and self.filename are give, an exception is raised.
        Optional preamble (boolean) : yes or no, do we add the preamble speaking about the scripts.
        
        """
        
        preamble = r"""% This file is automatically generated by some pre-compilation scripts.
%See
% https://github.com/LaurentClaessens/latexparser
% https://github.com/LaurentClaessens/phystricks
%Please contact the author at moky.math@gmail.com for asking original source file and scripts.
%
        """
        written_text=self.text_brut
        if preamble :
            written_text=preamble+written_text
        if filename:
            self.filename=filename
        else :
            filename = self.filename
        f = codecs.open(filename,"w","utf_8")
        f.write(written_text)
        f.close()
    def get_newlabel_value(self,label_name):
        r"""
        Assumes that self is a .aux file. Return the value associated to the line \newlabel{<label_name>}

        It it appears many times, return the last time, and prints a warning.

        If not found, raise an newlabelNotFound exception 
        """
        list_newlabel = self.analyse_use_of_macro("\\newlabel",2)
        if label_name not in [x.name for x in list_newlabel] :
            raise newlabelNotFound(label_name)
        list_interesting  = [x for x in list_newlabel if x.name==label_name]
        if len(list_interseting) > 1 :
            print("Warning : label %s has %s different values"%(label_name,str(len(list_interesting))))
        return list_interesting[-1].value
    def search_use_of_macro(self,name,number_of_arguments=None,give_configuration=False,fast=False):
        r"""
        Return a list of Occurrence of a given macro. You have to include the "\" in the name, for example
        codeLaTeX.search_use_of_macro("\MyMacro",2)
        is the good way to study the use of macro \MyMacro, provided that it has exactly 2 arguments.

        Optional argument: number_of_arguments=None
        If no occurrence are found, return an empty list.

        If give_configuration is True, return a tuple of two lists. The first list is the same as with give_configuration=False, and the second gives the 
        text between the occurrences. The ith element of the configuration list is what precedes the ith element of the occurrence list.
        The configuration list has one more element.
        The following has to be true
        self.text_brut==configuration[0]+occurrence[0]+...+configuration[n]+occurrence[n]+configuration[n+1]
        """
        # Why should I explicitly write the "\" in the macro name ?
        # I don't remember, but it was an issue.
        from latexparser.MacroUse import SearchUseOfMacro
        return SearchUseOfMacro(self,name,number_of_arguments,give_configuration,fast=fast)
    def analyse_use_of_macro(self,name,number_of_arguments=None):
        """
        Provide a list of analyse of the occurrences of a macro.

        Optional argument: number_of_arguments=None, to be passed to search_use_of_macro
        """
        return [occurence.analyse() for occurence in self.search_use_of_macro(name,number_of_arguments) ]
    def macro_definition(self,name):
        return MacroDefinition(self,name)
    def statistics_of_the_macro(self,name):
        return StatisticsOfTheMacro(self,name)
    def dict_of_definition_macros(self):
        r"""
        Returns a dictionary which gives, for each name of macros found to be defined in self.text, the occurrence 
        in which it was defined.
        If X is the output of dict_of_definition_macro, X.keys() is the list of the names of the macros and
        X.values() is the list of definition (type Occurrence_newcommand).

        The macro Foo is "defined" in the text when "Foo" comes as first argument of a definition command.
        (cf. the global variable definition_commands) Typically when
        \\newcommand{\Foo}[2]{bar}
        or
        \\renewcommand{\Foo}{bar}
        """
        if self._dict_of_definition_macros == {} :
            print("Je r√©invente la roue")
            dico = {}
            for definer in definition_commands :            
                for occurrence in self.search_use_of_macro(definer,3):
                    newcommand = Occurrence_newcommand(occurrence)
                    name = newcommand.name
                    if name in dico.keys() :
                        print("%s was already defined !!"%name)
                    else :
                        dico[name]=newcommand
            self._dict_of_definition_macros = dico
        return self._dict_of_definition_macros
    def list_of_input_files(self):
        if self._list_of_input_files == []:
            list = []
            for occurrence in self.search_use_of_macro("\input",1):
                list.append(occurrence.analyse().filename)
            self._list_of_input_files = list
        return self._list_of_input_files

    def substitute_occurence_input(self,occurence):
        """
        `occurence` is the occurence of an \input{<filename>}. 

        Replace the occurence by the content of filename.
        """
        text=occurence.substitution_text()
        print("Adding file",occurence.filename)
        A = LatexCode(self.text_brut)
        A.included_file_list=self.included_file_list
        A.included_file_list.append(occurence.filename)
        A=A.replace(occurence.as_written,text)
        return A
    def substitute_all_inputs(self,fast=False):
        r"""
        Recursively change all the \input{...} by the content of the corresponding file. 
        Return a new object latexparser.LatexCode
        """

        A = LatexCode(self.text_brut)

        # The \input macro search for the files in the directories
        # listed in \input@path. In mazhe I define the macro
        # \addInputPath in order to add a path in that list. We are here 
        # searching for the occurrence of \addInputPath in the file to be
        # expanded, so that we know in which directory we have to search for
        # the files that are inputed.
        list_addInputPath =\
                [x.analyse() for x in \
                A.search_use_of_macro(r"\addInputPath",1,fast=fast)]
        for occ in list_addInputPath :
            self.input_paths.append(occ.directory)
        list_input =\
                [x.analyse() for x in \
                A.search_use_of_macro("\input",1,fast=fast)]
        if list_input==[]:
            return self
        substitution_code={}
        for occurence in list_input:
            B=LatexCode(occurence.substitution_text(input_paths=self.input_paths))
            substitution_code[occurence]=B.substitute_all_inputs(fast=fast)
        for occ in list_input:
            A=A.substitute_occurence_input(occ)
        A.input_paths=self.input_paths
        return A
    def change_macro_argument(self,macro_name,n,func,n_args):
        r"""
        Apply the function <func> to the <n>th argument of each use of <macro_name>.

        return a new_object LatexCode
        """
        list_occurrences,configuration=self.search_use_of_macro(macro_name,n_args,give_configuration=True)
        a=""
        for i in range(len(list_occurrences)):
            a=a+configuration[i]+list_occurrences[i].change_argument(n,func).as_written
        a=a+configuration[-1]
        return LatexCode(a)
    def change_labels_refs(self,func):
        r"""
        Change \ref{MyLabel}, \eqref{MyLabel} and \label{MyLabel} applying func to the argument.
        """
        x=self.change_macro_argument(r"\ref",1,func,1)
        y=x.change_macro_argument(r"\eqref",1,func,1)
        z=y.change_macro_argument(r"\label",1,func,1)
        self.__init__(z.text_brut)
    def remove_macro_content(self,macro_name,number_of_arguments):
        r"""
        Remove the presence of a macro (not its definition). 
        Example

        Hello \MyMacro{guy} how do you do ?

        will become 
        Hello how do you do ?

        Return a new latexparser.LatexCode object.
        """
        A = self.copy()
        liste_occurrences = A.search_use_of_macro(macro_name,number_of_arguments)
        for occurrence in liste_occurrences :
            A=A.replace(occurrence.as_written,"")
        return A
    def remove_macro_name(self,macro_name,number_of_arguments):
        r"""
        Remove the macro name, but leaves the argument.
        Example

        Hello \MyMacro{guy} how do you do ?

        will become 
        Hello guy how do you do ?

        This function only works with a macro which has only one argument.
        """
        A = self.copy()
        liste_occurrences = A.search_use_of_macro(macro_name,number_of_arguments)
        for occurrence in liste_occurrences :
            A=A.replace(occurrence.as_written,occurrence.arguments[0])
        return A
    def position_to_line(self,position):
        """
        return the line (as string) which contains the given position.
        """
        a=self.text_brut[0:position].rindex("\n")
        b=self.text_brut.index("\n",position)
        return self.text_brut[a+1:b]
    def find(self,arg):
        # Up to November 25, 2014, it was 'text' instead of 'text_brut'.
        # and it was a bug.
        return self.text_brut.find(arg)
    def replace(self,textA,textB):
        """ Replace textA by textB including in the comments """
        textA=ensure_unicode(textA)
        textB=ensure_unicode(textB)
        new_text = self.text_brut.replace(textA,textB)
        A = LatexCode(new_text,oldLaTeX=self)
        return A
    def splitlines(self):
        textA=self.text_brut
        return textA.splitlines()   
    def append_file(self,filename=None,filenames=None):
        """
        Append the content of a file to the current LaTeX code. Return a new object.

        If filename is given, add only this file
        If filenames is given, add all the files.

        See the method __add__
        """
        if filename :
            if ".tex" not in filename :
                filename = filename+".tex"
            new = self+FileToLatexCode(filename)
            self.__init__(new.text_brut)
        if filenames :
            for i in range(len(filenames)):
                if ".tex" not in filenames[i] :
                    filenames[i] = filenames[i]+".tex"
            a = ""
            for f in filenames :
                a=a+FileToText(f)
            add_given_text=a
            self.__init__(self.given_text+add_given_text)
    def rough_source(self,filename,bibliography_bbl_filename=None,index_ind_filename=None,fast=False):
        """
        Return the name of a file where there is a rough latex
        code ready to be published to Arxiv
        """
        from latexparser.RoughSources import LatexCodeToRoughSource
        return LatexCodeToRoughSource(self,filename,bibliography_bbl_filename,index_ind_filename,fast=fast)
    def __add__(self,other):
        new_given_text=self.given_text+other.given_text
        return LatexCode(new_given_text)

